\section{Các phương pháp giải bài toán}

Phần này mô tả các phương pháp nhóm em đã sử dụng để giải bài toán thỏa mãn mệnh đề (SAT) ở trên sau khi đã chuyển bài toán Hashiwokakero về dạng mệnh đề SAT dưới dạng CNF .

\subsection{PySAT}

PySAT là một thư viện Python cung cấp giao diện đơn giản để tương tác với nhiều bộ giải SAT hiệu quả, trong đó có Glucose3 — một solver SAT hiện đại dựa trên thuật toán Conflict-Driven Clause Learning (CDCL), nổi bật về tốc độ và khả năng xử lý các công thức CNF phức tạp.

Trong đồ án này, chúng em đã sử dụng PySAT với solver Glucose3 để giải các công thức CNF biểu diễn các ràng buộc của bài toán Hashiwokakero. 

\subsection{Thuật toán A* giải SAT cho bài toán Hashiwokakero}

Thuật toán sử dụng phương pháp tìm kiếm theo A* trên không gian trạng thái các gán biến cho công thức CNF biểu diễn bài toán Hashiwokakero.

\paragraph{Input:}
\begin{itemize}
    \item Công thức CNF dưới dạng danh sách các clause, mỗi clause là danh sách literal (biến hoặc phủ định biến).
    \item Số biến tối đa trong công thức.
    \item Thời gian timeout để tránh chạy quá lâu.
\end{itemize}

\paragraph{Ý tưởng chính:}
\begin{itemize}
    \item Mỗi trạng thái trong tìm kiếm là một ánh xạ (dictionary) biểu diễn gán giá trị True/False cho một số biến.
    \item \textbf{Heuristic}: số lượng clause chưa chắc chắn thỏa (chưa có literal True, hoặc chưa bị xung đột).
    \item Thuật toán mở rộng trạng thái bằng cách chọn biến chưa gán nhỏ nhất và thử gán True hoặc False, loại bỏ các trạng thái gây mâu thuẫn (conflict).
    \item Sử dụng \texttt{heapq} để quản lý hàng đợi ưu tiên theo giá trị \( f = g + h \).
    \item Lưu tập trạng thái đã duyệt để tránh lặp.
    \item Giới hạn thời gian chạy bằng timeout.
\end{itemize}

\begin{algorithm}[H]
\caption{A* SAT Solver cho bài toán Hashiwokakero}
\KwIn{Danh sách clause \texttt{clauses}, số biến \(n\), thời gian timeout \(T\)}
\KwOut{Nghiệm gán biến thỏa mãn CNF hoặc báo thất bại}

Khởi tạo hàng đợi ưu tiên \texttt{frontier} \\
Khởi tạo tập trạng thái đã duyệt \texttt{visited} \\
Khởi tạo trạng thái bắt đầu: ánh xạ gán rỗng \\
Tính heuristic \(h\) cho trạng thái bắt đầu \\
Đưa trạng thái bắt đầu vào \texttt{frontier} với độ ưu tiên \(f = g + h = 0 + h\) \\
Bắt đầu đếm thời gian \\

\While{\texttt{frontier} không rỗng}{
    \If{thời gian chạy vượt quá \(T\)}{
        Trả về thất bại do timeout
    }
    Lấy trạng thái có độ ưu tiên thấp nhất: \((f, g, assignment)\) từ \texttt{frontier} \\
    Tăng biến đếm số node đã mở rộng

    \If{\(assignment\) đã có trong \texttt{visited}}{
        \textbf{continue}
    }
    Thêm \(assignment\) vào \texttt{visited} \\

    \If{trạng thái hiện tại gây mâu thuẫn (conflict)}{
        \textbf{continue}
    }

    \If{trạng thái hiện tại thỏa công thức CNF}{
        Trả về nghiệm \(assignment\)
    }

    Chọn biến chưa gán nhỏ nhất \(var\) \\
    \For{\(val \in \{True, False\}\)}{
        Tạo trạng thái mới \(assignment'\) gán \(var = val\) \\
        \If{\(assignment'\) không gây mâu thuẫn}{
            Tính heuristic \(h'\) cho \(assignment'\) \\
            Đặt \(g' = g + 1\) và \(f' = g' + h'\) \\
            Đưa trạng thái \((f', g', assignment')\) vào \texttt{frontier}
        }
    }
}

Trả về thất bại do không tìm thấy nghiệm hợp lệ
\end{algorithm}

\paragraph{Đặc điểm triển khai:}

\begin{itemize}
    \item Theo dõi số node đã mở rộng và thời gian chạy để đánh giá hiệu quả thuật toán.
    \item Sử dụng \texttt{tracemalloc} để theo dõi bộ nhớ đỉnh trong quá trình chạy.
    \item Ánh xạ trạng thái được lưu dưới dạng tuple các cặp biến-giá trị đã gán, đảm bảo không lặp lại.
    \item Cắt tỉa nhanh nhờ kiểm tra mâu thuẫn sớm khi mở rộng trạng thái mới.
    \item Thuật toán chỉ xét một biến chưa gán mỗi lượt để giảm độ phức tạp.
\end{itemize}

\subsection{Các thuật toán bổ sung để so sánh}

Để đánh giá hiệu quả của A*, nhóm còn triển khai: 

\begin{itemize}
    \item \textbf{Thuật toán A* Graph (Thuật toán A* dựa trên đồ thị)}: Đây là thuật toán A* thuần túy dựa trên biểu diễn đồ thị của bài toán, không chuyển đổi sang công thức SAT. Thuật toán mở rộng các trạng thái bằng cách thêm cầu vào các cạnh, sử dụng hàm heuristic ước lượng chi phí còn lại dựa trên số cầu cần thêm và số thành phần liên thông chưa kết nối đủ. Thuật toán đo lường số node đã mở rộng, thời gian thực thi và mức sử dụng bộ nhớ cao nhất trong quá trình chạy để so sánh hiệu quả với các thuật toán khác.
    \item \textbf{Thuật toán Brute-force (Tìm kiếm toàn diện)}: Đây là phương pháp tìm kiếm tất cả các khả năng có thể gán số cầu trên từng cạnh, không sử dụng bất kỳ kỹ thuật cắt tỉa nào. 
    
    \item \textbf{Thuật toán Backtracking (Tìm kiếm có cắt tỉa)}: Thuật toán này cải tiến so với brute-force bằng cách kết hợp kỹ thuật cắt tỉa (pruning) để loại bỏ sớm các nhánh tìm kiếm không khả thi dựa trên các ràng buộc như giới hạn số cầu tại đảo và tránh tạo cầu chồng. Việc cắt tỉa giúp giảm đáng kể không gian tìm kiếm và tăng tốc độ xử lý so với brute-force thuần túy.
    
    \item \textbf{Thuật toán Backtracking Graph}: Thuật toán duy trì trạng thái hiện tại dưới dạng một đồ thị với các đảo và các cầu đã xây dựng, đồng thời kiểm tra tính kết nối và giới hạn cầu tại mỗi đảo trong quá trình tìm kiếm. 
\end{itemize}

Nhờ có các thuật toán bổ sung này, nhóm có thể đánh giá toàn diện hiệu quả của A* về mặt thời gian xử lý, bộ nhớ sử dụng và khả năng mở rộng, từ đó lựa chọn thuật toán phù hợp nhất cho các trường hợp cụ thể trong bài toán Hashiwokakero.

Các thuật toán này giúp so sánh hiệu năng về tốc độ và bộ nhớ sử dụng.

