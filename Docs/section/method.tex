\section{Các phương pháp giải bài toán}

Phần này mô tả các phương pháp nhóm em đã sử dụng để giải bài toán thỏa mãn mệnh đề (SAT) sau khi đã chuyển bài toán Hashiwokakero về dạng mệnh đề SAT dưới dạng CNF.

\subsection{PySAT}

PySAT là một thư viện Python cung cấp giao diện đơn giản để tương tác với nhiều bộ giải SAT hiệu quả, trong đó có Glucose3 \cite{pysat-doc}— một solver SAT hiện đại dựa trên thuật toán Conflict-Driven Clause Learning (CDCL), nổi bật về tốc độ và khả năng xử lý các công thức CNF phức tạp.

Trong đồ án này, nhóm em đã sử dụng PySAT với solver Glucose3 để giải các công thức CNF biểu diễn các ràng buộc của bài toán Hashiwokakero.

\subsection{Thuật toán A* SAT cho bài toán Hashiwokakero}

Thuật toán A* SAT giải bài toán Hashiwokakero bằng cách áp dụng tìm kiếm A* trên không gian các gán giá trị từng phần cho các biến SAT trong công thức CNF được xây dựng từ bài toán. 
Mỗi trạng thái trong quá trình tìm kiếm tương ứng với một \textit{partial assignment} của các biến Boolean, và việc mở rộng trạng thái được dẫn hướng bởi hàm heuristic admissible.

\paragraph{Mô tả thuật toán}

\begin{itemize}
    \item \textbf{Trạng thái}:  
    Mỗi trạng thái được biểu diễn bởi một tập gán biến SAT từng phần \texttt{assignment}, ánh xạ từ chỉ số biến sang giá trị Boolean. 
    Trạng thái được chuẩn hóa dưới dạng \texttt{frozenset} để có thể lưu và kiểm tra trong tập \texttt{visited}.

    \item \textbf{Lan truyền đơn vị (Unit Propagation)}:  
    Trước khi mở rộng một trạng thái, thuật toán thực hiện lan truyền đơn vị trên toàn bộ tập mệnh đề CNF. 
    Nếu một mệnh đề chỉ còn duy nhất một literal chưa được gán, literal đó sẽ bị ép giá trị bắt buộc. 
    Nếu xuất hiện mệnh đề mà tất cả các literal đều bị gán sai, trạng thái hiện tại bị loại bỏ do mâu thuẫn.

    \item \textbf{Hàm heuristic}:  
    Heuristic được sử dụng để ước lượng chi phí còn lại như sau:
    \[
        h(n) = n_{\text{vars}} - |\texttt{assignment}|
    \]
    trong đó \( n_{\text{vars}} \) là tổng số biến SAT và \( |\texttt{assignment}| \) là số biến đã được gán. 
    Heuristic này ước lượng số bước còn lại cần thiết để hoàn tất phép gán và đảm bảo tính admissible.

    \item \textbf{Hàm đánh giá}:  
    Thuật toán A* sử dụng hàm:
    \[
        f(n) = g(n) + h(n)
    \]
    với:
    \begin{itemize}
        \item \( g(n) \): số biến đã được gán (chi phí đã đi)
        \item \( h(n) \): số biến chưa được gán (chi phí ước lượng còn lại)
    \end{itemize}

    \item \textbf{Chiến lược mở rộng}:  
    Tại mỗi trạng thái, thuật toán chọn biến SAT chưa được gán có chỉ số nhỏ nhất và lần lượt thử gán giá trị \texttt{True} và \texttt{False}. 
    Các trạng thái con được đưa vào hàng đợi ưu tiên dựa trên giá trị \( f \).

    \item \textbf{Tránh lặp trạng thái}:  
    Các trạng thái đã được duyệt được lưu trong tập \texttt{visited} để tránh mở rộng lại các cấu hình gán trùng lặp.

    \item \textbf{Điều kiện dừng}:  
    Khi tất cả các biến đã được gán và mô hình hiện tại thỏa mãn toàn bộ các mệnh đề CNF, thuật toán kết thúc và trả về nghiệm. 
    Thuật toán cũng dừng khi vượt quá thời gian giới hạn \texttt{timeout}.
\end{itemize}

\paragraph{Ưu điểm của heuristic}

\begin{itemize}
    \item Heuristic đơn giản và admissible, không đánh giá quá cao chi phí còn lại.
    \item Phù hợp với không gian tìm kiếm SAT, nơi mỗi bước tương ứng với việc gán thêm một biến.
    \item Khi kết hợp với lan truyền đơn vị, heuristic giúp phát hiện sớm các nhánh mâu thuẫn, từ đó giảm đáng kể số node cần mở rộng.
\end{itemize}

\begin{algorithm}[H]
\caption{A* SAT Solver cho bài toán Hashiwokakero}
\KwIn{Công thức CNF với \(n\) biến SAT, thời gian giới hạn \(T\)}
\KwOut{Mô hình gán biến thỏa CNF hoặc báo thất bại}

Khởi tạo \texttt{assignment} rỗng \\
Tính \( h_0 = n - |\texttt{assignment}| \) \\
Khởi tạo hàng đợi ưu tiên \texttt{pq} theo giá trị \( f = g + h \) \\
Khởi tạo tập trạng thái đã duyệt \texttt{visited} \\
Bắt đầu đếm thời gian \\

\While{\texttt{pq} không rỗng}{
    Lấy trạng thái có \( f \) nhỏ nhất từ \texttt{pq} \\
    \If{thời gian vượt quá \( T \)}{
        Trả về thất bại
    }

    Áp dụng lan truyền đơn vị \\
    \If{phát sinh mâu thuẫn}{
        Bỏ qua trạng thái
    }

    \If{trạng thái đã tồn tại trong \texttt{visited}}{
        Bỏ qua trạng thái
    }
    Đánh dấu trạng thái hiện tại là đã duyệt \\

    \If{tất cả biến đã được gán}{
        \If{mô hình thỏa mãn CNF}{
            Trả về nghiệm
        }
    }

    Chọn biến SAT chưa được gán \\
    \ForEach{giá trị \( \in \{\texttt{True}, \texttt{False}\} \)}{
        Gán giá trị cho biến \\
        Tính lại \( g, h, f \) \\
        Đưa trạng thái mới vào \texttt{pq}
    }
}
Trả về thất bại do không tìm được nghiệm
\end{algorithm}

\paragraph{Thông số đánh giá}

Thuật toán theo dõi các chỉ số sau:
\begin{itemize}
    \item Số node đã mở rộng (\texttt{node\_expanded})
    \item Thời gian thực thi
    \item Mức sử dụng bộ nhớ đỉnh (đo bằng \texttt{tracemalloc})
    \item Trạng thái giải: thành công hoặc thất bại
\end{itemize}

\subsection{Các thuật toán bổ sung để so sánh}

Để đánh giá hiệu quả của A*, nhóm còn triển khai: 

\begin{itemize}
    \item \textbf{Thuật toán A* Graph (Thuật toán A* dựa trên đồ thị)}: Đây là thuật toán A* thuần túy dựa trên biểu diễn đồ thị của bài toán, không chuyển đổi sang công thức SAT. Thuật toán mở rộng các trạng thái bằng cách thêm cầu vào các cạnh, sử dụng hàm heuristic ước lượng chi phí còn lại dựa trên số cầu cần thêm và số thành phần liên thông chưa kết nối đủ. Thuật toán đo lường số node đã mở rộng, thời gian thực thi và mức sử dụng bộ nhớ cao nhất trong quá trình chạy để so sánh hiệu quả với các thuật toán khác.
    \item \textbf{Thuật toán Brute-force (Tìm kiếm toàn diện)}: Đây là phương pháp tìm kiếm tất cả các khả năng có thể gán số cầu trên từng cạnh, không sử dụng bất kỳ kỹ thuật cắt tỉa nào. 
    \item \textbf{Thuật toán Backtracking (Tìm kiếm có cắt tỉa)}: Thuật toán này cải tiến so với brute-force bằng cách kết hợp kỹ thuật cắt tỉa (pruning) để loại bỏ sớm các nhánh tìm kiếm không khả thi dựa trên các ràng buộc như giới hạn số cầu tại đảo và tránh tạo cầu chồng. Việc cắt tỉa giúp giảm đáng kể không gian tìm kiếm và tăng tốc độ xử lý so với brute-force thuần túy.
    \item \textbf{Thuật toán Backtracking Graph}: Thuật toán duy trì trạng thái hiện tại dưới dạng một đồ thị với các đảo và các cầu đã xây dựng, đồng thời kiểm tra tính kết nối và giới hạn cầu tại mỗi đảo trong quá trình tìm kiếm. 
\end{itemize}

Nhờ có các thuật toán bổ sung này, nhóm có thể đánh giá toàn diện hiệu quả của A* về mặt thời gian xử lý, bộ nhớ sử dụng và khả năng mở rộng, từ đó lựa chọn thuật toán phù hợp nhất cho các trường hợp cụ thể trong bài toán Hashiwokakero.

Các thuật toán này giúp so sánh hiệu năng về tốc độ và bộ nhớ sử dụng.
